# 社区便民路线规划与活动主题分配
## —— 无向图生成树与点着色模型实现

---

## 1. 项目背景

社区内分布着健身区、儿童乐园、休闲亭、阅读角等多个公共活动点。  
为提升居民出行便利性并控制建设与维护成本，需规划一套 **“最小必要便民路线”**，该路线需覆盖所有活动点，且不存在冗余路径，保证任意两个活动点之间均可到达。

与此同时，社区还需为每个活动点安排特色主题活动（如亲子互动、老年康养、青年社交等）。  
由于 **相邻活动点若安排相同主题容易造成人流集中与拥挤**，因此需确保沿直达路线相邻的活动点分配不同的活动主题。

本项目使用离散数学中的 **图论模型**，将上述问题抽象为 **生成树构建问题** 与 **无向图点着色问题**，并通过程序实现活动主题分配的可行性验证。

---

## 2. 数学模型说明

### 2.1 无向简单图建模

将社区活动点网络建模为无向简单图：

- 图：`G = (V, E)`
- 顶点 `V`：社区公共活动点
- 边 `E`：两个活动点之间“距离近且需要直达路线”的关系

采用邻接矩阵 `A` 表示图结构：

- `A[i][j] = 1`：第 `i` 与第 `j` 个活动点之间存在直达路线
- `A[i][j] = 0`：不存在直达路线
- 矩阵对称，且 `A[i][i] = 0`

---

### 2.2 最小必要便民路线（生成树）

为控制路线建设与维护成本，从原始连通图中构造 **生成树**：

- 覆盖全部顶点
- 不含回路
- 边数为 `n - 1`

生成树在保证所有活动点连通的前提下，实现了路线数量的最小化。

---

### 2.3 活动主题分配（点着色模型）

将活动主题分配问题抽象为无向图的 **正常点着色问题**：

- 每个主题对应一种颜色
- 每个顶点分配一个颜色
- 任意有边相连的顶点颜色不同

若存在函数：f : V → {1, 2, ..., k}

满足：∀ {vi, vj} ∈ E, f(vi) ≠ f(vj)

则称图 `G` 为 **k-可着色图**。

---

### 2.4 点色数 χ(G)

图 `G` 的点色数定义为：

χ(G) = min { k | G 是 k-可着色的 }


现实意义：

- `χ(G)` 表示完成合法主题分配所需的最少主题种类数
- 若给定主题数 `k ≥ χ(G)`，则主题分配可行
- 若 `k < χ(G)`，则必然出现相邻活动点主题冲突

---

## 3. 程序功能

本项目程序基于回溯算法，实现以下功能：

1. 输入社区活动点邻接矩阵  
2. 判断给定 `k` 种主题是否可行（k-点着色判定）  
3. 计算图的点色数 `χ(G)`  
4. 输出一组合法的主题分配方案  

程序适用于顶点数 `n ≤ 10` 的实验规模。

---

## 4. 算法设计思想

### 4.1 回溯法（Backtracking）

程序采用深度优先搜索策略：

- 按顺序为顶点尝试分配主题
- 若当前分配与已分配的相邻顶点冲突，则回溯
- 当所有顶点成功分配主题时，得到一个合法方案

该过程等价于枚举所有可能的主题分配函数，并通过相邻约束进行剪枝。

---

### 4.2 点色数计算方法

从 `k = 1` 开始递增尝试：

- 若图可以用 `k` 种颜色合法着色，则该 `k` 即为点色数 `χ(G)`

---

## 5. 使用说明

### 5.1 修改邻接矩阵

在代码中修改邻接矩阵 `A`，例如：

```python
A = [
    [0, 1, 1, 0],
    [1, 0, 1, 1],
    [1, 1, 0, 1],
    [0, 1, 1, 0]
]

矩阵规模不超过 10 × 10。
