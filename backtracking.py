# ==========================================
# 社区活动主题分配（点着色验证）—— 无向图 k-着色
# 模型对应：
#   顶点 V：活动点（健身区、儿童乐园等）
#   边 E：两个活动点之间“需要直达路线”的关系
#   颜色/主题：1..k
#   正常点着色约束：相邻顶点颜色不同
# 目标：
#   1) 判断给定 k 种主题是否可行（k-colorable）
#   2) 求最少主题数 χ(G)（chromatic number）
#   3) 给出一组可行的主题分配方案（一个着色解）
# ==========================================


# ---------- 1. 输入邻接矩阵 A ----------
# A 是 n 阶对称矩阵：
#   A[i][j] = 1 表示顶点 i 与顶点 j 之间有边（活动点近、可直达）
#   A[i][j] = 0 表示没有边
# 注意：无向简单图要求 A[i][i]=0 且 A[i][j]=A[j][i]
A = [
    [0, 1, 1, 0],
    [1, 0, 1, 1],
    [1, 1, 0, 1],
    [0, 1, 1, 0]
]

n = len(A)  # 顶点数 n（活动点总数）

# color[i] 表示第 i 个顶点分配到的“主题编号/颜色编号”
# 约定：
#   color[i] = 0   表示该顶点还未分配主题
#   color[i] = 1..k 表示分配了某个主题
color = [0] * n


# ---------- 2. 合法性检查：is_valid(v, c) ----------
def is_valid(v, c):
    """
    判断：是否可以把顶点 v 分配为主题 c（染成颜色 c）

    图论意义：
      如果 v 与某个邻居 u 有边相连（A[v][u]=1），
      则必须满足 color[u] != c。
    即：
      对所有 {v,u} ∈ E，有 f(v) != f(u)

    参数：
      v: 当前要染色（分配主题）的顶点编号（0..n-1）
      c: 试探的颜色/主题编号（1..k）

    返回：
      True  - 可以染（不会与已染色邻居冲突）
      False - 不可以染（至少存在一个相邻顶点颜色相同）
    """
    for u in range(n):
        # 如果 v 和 u 相邻（有边），且 u 已经被染成 c，则冲突
        if A[v][u] == 1 and color[u] == c:
            return False
    return True


# ---------- 3. 回溯搜索：dfs(v, k) ----------
def dfs(v, k):
    """
    使用回溯（Backtracking）尝试对图进行 k-着色。
    核心思想：逐个顶点尝试分配颜色，遇到冲突就回退重试。

    状态（State）：
      color[0..n-1] 当前已分配的主题/颜色

    递归含义：
      dfs(v, k) 表示：从第 v 个顶点开始，尝试把 v..n-1 都染好

    终止条件：
      当 v == n 时，说明 0..n-1 全部顶点都成功染色 -> 找到一个合法方案

    返回：
      True  - 找到了合法 k-着色
      False - 无法完成 k-着色（需要更多颜色）
    """
    # 所有顶点都处理完了 -> 成功
    if v == n:
        return True

    # 依次尝试给顶点 v 分配 1..k 号主题
    for c in range(1, k + 1):
        # 只有当分配 c 不与已分配的邻居冲突时，才可以继续
        if is_valid(v, c):
            color[v] = c  # 选择：给 v 分配主题 c

            # 递归尝试给下一个顶点分配
            if dfs(v + 1, k):
                return True  # 只要后面能成功，就整体成功

            # 回溯：如果后面失败，撤销当前选择，换别的颜色再试
            color[v] = 0

    # 如果 1..k 都试过仍不行，说明从当前状态出发无法完成 k-着色
    return False


# ---------- 4. 判定：图是否 k-可着色 ----------
def k_colorable(k):
    """
    判断图 G 是否可以用 k 种颜色进行正常点着色（k-colorable）。

    做法：
      清空 color 数组，然后用 dfs(0, k) 尝试给所有顶点着色。

    返回：
      True  - 存在一个合法分配 f: V -> {1..k}
      False - 不存在（k 太小，必然冲突）
    """
    # 清空颜色（每次判定都必须从未染色开始）
    for i in range(n):
        color[i] = 0

    return dfs(0, k)


# ---------- 5. 求点色数：χ(G) ----------
def chromatic_number():
    """
    计算图的点色数 χ(G)：
      χ(G) = 最小的 k，使得图 G 是 k-可着色的。

    做法：
      从 k=1 开始逐步尝试：
        如果 k_colorable(k) 为 True，则该 k 就是 χ(G)。

    性能说明：
      点着色判定是 NP-Complete，但 n<=10 时回溯法完全可用。
    """
    for k in range(1, n + 1):
        if k_colorable(k):
            return k
    return n


# ---------- 6. 主程序 ----------
if __name__ == "__main__":
    # 先求最小主题数（点色数）
    chi = chromatic_number()
    print("图的点色数 χ(G) =", chi)

    # chromatic_number() 返回时，color[] 已经保存了一组合法着色方案
    print("一种合法的主题分配方案（顶点 -> 主题编号）：")
    for i in range(n):
        print(f"活动点 v{i + 1} -> 主题 {color[i]}")

    # 你也可以只验证某个给定的 k：
    # k = 3
    # if k_colorable(k):
    #     print(f"可以用 {k} 种主题合法分配：", color)
    # else:
    #     print(f"不可以用 {k} 种主题合法分配")
